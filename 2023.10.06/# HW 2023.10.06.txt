АТРИБУТЫ КЛАССОВ И ЭКЗЕМПЛЯРОВ

  ==========  1  ==========  

Написать класс с именем Tetrahedron, который описывает правильный тетраэдр.

Поля класса отсутствуют.

Атрибуты экземпляра:
    - edge - длина ребра: float

Методы:
    - __init__ - конструктор класса
    - surface - вычисляет площадь поверхности -> float
    - volume - вычисляет объём тела -> float

Параметры конструктора:
    - edge: float

Информация о правильном тетраэдре:
    https://mnogogranniki.ru/tetraedr.html

Работу написанного класса необходимо протестировать.

Пример теста:
    >>> t1 = Tetrahedron(5)
    >>> t1.edge
    5.0
    >>> t1.surface()
    43.30127018922193
    >>> t1.volume()
    14.731391274719739
    >>> 
    >>> t1.edge = 6
    >>> t1.surface()
    62.35382907247958



  ==========  2  ==========  

Написать класс с именем PowerMeter, который описывает двухтарифный счётчик потреблённой электрической мощности.

Поля класса отсутствуют.

Атрибуты экземпляра:
    - tariff1 - первый тариф: decimal.Decimal
    - tariff2 - второй тариф: decimal.Decimal
    - tariff2_starts - время начала действия второго тарифа: datetime.time
    - tariff2_ends - время окончания действия второго тарифа: datetime.time
    - power - суммарная потреблённая мощность: decimal.Decimal
    - charges - начисления за каждый месяц согласно тарифным планам: dict[datetime.date, decimal.Decimal]
    
    Диапазон времени, задаваемый значениями tariff2_starts и tariff2_ends, устанавливает безотносительно даты только время суток, в течение которого действует второй тариф
    
    Ключами словаря charges должны являться первые числа каждого очередного месяца, представленные типом datetime.date
    
    Значениями словаря charges должны являться значения стоимости потреблённой мощности в течение соответствующего месяца — как и любая финансовая величина, эти значения используют тип вещественных чисел с фиксированной точкой и округляются до двух десятичных знаков

Методы:
    - __init__ - конструктор класса
    - __repr__ - машиночитаемое строковое представление
    - __str__ - человекочитаемое строковое представление
    - meter - принимает значение потреблённой мощности, вычисляет и возвращает стоимость согласно тарифному плану, действующему в текущий момент -> decimal.Decimal
    
    Форматы строковых представлений необходимо взять из примеров ниже.
    
    Обратите внимание, что метод meter() вычисленное значение стоимости должен добавить к сохранённому значению в атрибуте charges по ключу, который формируется на основании текущей даты. При этом метод meter() возвращает стоимость, соответствующую переданному значению потреблённой мощности, а не накопленную за весь месяц.

Параметры конструктора:
    - tariff1: numbers.Number = ...
    - tariff2: numbers.Number = ...
    - tariff2_starts: datetime.time = ...
    - tariff2_ends: datetime.time = ...
    
    Обратите внимание, что в качестве аргументов для тарифов могут быть переданы числа произвольного типа, в то время как в атрибут экземпляра должен быть записан именно объект типа decimal.Decimal
    
    = ... в данном контексте указывает на необходимость подстановки значения по умолчанию

Параметры meter:
    - power: numbers.Number

Работу написанного класса необходимо протестировать.

Пример теста:
    >>> pm1 = PowerMeter()
    >>> 
    >>> pm1.meter(2)
    Decimal('13.00')
    >>> pm1.meter(1.2)
    Decimal('7.80')
    >>> 
    >>> pm
    <PowerMeter: 3.2 кВт/ч>
    >>> print(pm1)
    (Jul) 20.80



  ==========  3  ==========  

Написать класс с именем ChessKing, который описывает шахматную фигуру короля.

Поля класса:
    - files - соответствие между буквой, обозначающей вертикаль шахматной доски, и числом: dict[str, int]
    - ranks - соответствие между строковым представлением числа, обозначающего горизонталь шахматной доски, и числом: dict[str, int]

Атрибуты экземпляра:
    - color - цвет фигуры: str
    - square - поле шахматной доски, на котором в данный момент находится фигура: str

Методы:
    - __init__ - конструктор класса
    - __repr__ - машиночитаемое строковое представление
    - __str__ - человекочитаемое строковое представление
    - is_turn_valid - принимает на вход строку нового поля и проверяет, возможен ли для данной фигуры ход с текущего поля на новое -> bool
    - turn - принимает на вход строку нового поля и выполняет ход, выбрасывает ValueError в случае невозможности выполнить ход -> None
    
    Машиночитаемое и человекочитаемое строковые представления для данного класса аналогичны, их формат необходимо взять из примера ниже
    
    Выполнение хода в данном случае осуществляется с помощью перезаписи значения атрибута square. Возможное наличие фигуры на поле назначения игнорировать
    
    Выброс исключения осуществляется с помощью инструкции raise:
    >>> raise TypeError
    ...
    TypeError

Параметры конструктора:
    - color: str = 'white'
    - square: str = None
    
    В случае, если аргумент для square не передан, то в соответствующий атрибут экземпляра должна быть записана начальная позиция фигуры соответствующего цвета

Параметры is_turn_valid:
    - new_square: str

Параметры turn:
    - new_square: str

Работу написанного класса необходимо протестировать.

Пример теста:
    >>> wk = ChessKing()
    >>> wk.color
    'white'
    >>> wk.square
    'e1'
    >>>
    >>> wk.turn('e2')
    >>> wk
    'WK: e2'
    >>>
    >>> wk.turn('d4')
    ... 
    ValueError
    >>> 
    >>> bk = ChessKing('black')
    >>> print(bk)
    BK: e8



  ==========  4  ==========  

Написать класс с именем CountableNouns, который предоставляет интерфейс для работы с файловой базой существительных.

Поля класса:
    - db_path - путь к файлу с базой существительных: pathlib.Path
    - words - соответствие между существительным в единственном числе и кортежем из двух словоформ/слов во множественном числе, согласующихся с числительными "два" и "пять": dict[str, tuple[str, str]]
    
    Файл с тестовой базой существительных words.csv находится в каталоге домашнего задания. Для работы с файлами формата CSV используются функции reader() и writer() из модуля стандартной библиотеки csv. Подробнее об использовании этих функций в документации:
        https://docs.python.org/3/library/csv.html#module-contents
                
        При вызове функции writer() передайте значение '\n' в ключевой параметр lineterminator
    
    Чтение из файла с базой существительных и запись значений в словарь words должно осуществляться во время создания объекта класса

Атрибуты экземпляра отсутствуют.

Методы:
    - {class} pick - принимает в качестве аргументов число и существительное для согласования в единственном числе, возвращает согласованное с переданным числом существительное -> str
    - {class} save_words - запрашивает в stdin у пользователя два или три слова согласующихся с числительными, добавляет полученные значения в поле класса words и дописывает их в файл с базой существительных -> None
    
    {class} в данном контексте указывает на необходимость определения классового метода
    
    В случае, если переданное в метод pick() существительное отсутствует в базе, должен быть вызван метод save_words() с передачей последнему этого существительного в качестве аргумента

Параметры pick:
    - number: int
    - word: str

Параметры save_words:
    - word1: str = None
    
    При вызове данного метода с передачей слова в единственном числе достаточно запросить два слова для согласования с числительными "два" и "пять"
    
    Данный метод также может быть вызван отдельно, без передачи аргумента: в этом случае метод должен запросить все три слова для согласования с числительными "один", "два" и "пять" (см. тест ниже)

Работу написанного класса необходимо протестировать.

Пример теста:
    >>> CountableNouns.words
    {'год': ('года', 'лет'), 'месяц': ('месяца', 'месяцев'), 'день': ('дня', 'дней')}
    >>> 
    >>> CountableNouns.pick(22, 'год')
    'года'
    >>> CountableNouns.pick(365, 'день')
    'дней'
    >>> 
    >>> CountableNouns.pick(21, 'попугай')
    'попугай'
    >>> CountableNouns.pick(22, 'попугай')
    существительное "попугай" отсутствует в базе
      введите слово, согласующееся с числительным "два": попугая
      введите слово, согласующееся с числительным "пять": попугаев
    >>>
    >>> CountableNouns.words
    {'год': ('года', 'лет'), 'месяц': ('месяца', 'месяцев'), 'день': ('дня', 'дней'), 'попугай': ('попугая', 'попугаев')}
    >>>
    >>> CountableNouns.save_words()
     введите слово, согласующееся с числительным "один": капля
      введите слово, согласующееся с числительным "два": капли
      введите слово, согласующееся с числительным "пять": капель
    >>>
    >>> print(CountableNouns.db_path.read_text(encoding='utf-8'))
    год,года,лет
    месяц,месяца,месяцев
    день,дня,дней
    попугай,попугая,попугаев
    капля,капли,капель



  =========================

Каждый класс должен быть документирован. 
Каждый метод кроме встроенных (специальных) должен быть документирован.

Каждое поле класса должно быть аннотировано. 
Атрибуты экземпляра аннотируются в том случае, если типы их значений не совпадают с соответствующими переданными в конструктор аргументами, или если атрибуты создаются безотносительно переданных в конструктор аргументов.
Каждый параметр (кроме self и cls) всех методов должен быть аннотирован. 
Каждое возвращаемое значение методов кроме встроенных (специальных) должно быть аннотировано.

Во всех случаях аннотация опускается, если с аннотируемым идентификатором может быть связан объект произвольного типа.

Помимо перечисленных в каждой задаче обязательных атрибутов классов и экземпляров возможно добавление собственных вспомогательных атрибутов и методов.

Работа классов тестируется в режиме инспекции файла с кодом.
Ввод и вывод в стандартные потоки результатов тестов копируются.
Копия в виде комментария помещается в конец файла с кодом задачи.

Невыполнение дополнительных задач не повлечёт снижения баллов за задание. Тем не менее они настоятельно рекомендуются к решению.

В сервис Журнал отправляется сообщение о выполнении всех частей задания со ссылкой на репозиторий.

Преподаватель пишет комментарии и правки в коде задач и обновляет файлы в удалённом репозитории.
Регулярно получайте обновления в свой локальный репозиторий из удалённого репозитория.