СПЕЦИАЛЬНЫЕ МЕТОДЫ И СВОЙСТВА

  ==========  1  ==========  

Написать класс с именем Matrix, который описывает матрицу чисел.
Элементами матрицы могут быть объекты любого числового типа.

Введение в матрицы и матричное исчисление: https://thecode.media/matrix-101/
Подробное методическое пособие по матрицам находится в каталоге с заданием

Данный класс будет моделировать изменяемую матрицу. Для этого экземпляр данного класса должен индексироваться как список списков чисел.

Класс должен поддерживать операции:
  - транспонирования
  - поэлементного сложения с другой матрицей и числом
  - поэлементного вычитания с другой матрицей и числом
  - поэлементного умножения на число
  - унарного отрицания
  - строкового представления матрицы с выравниванием столбцов

Необходимо минимизировать повторения кода для перегружающих операторы методов.


Поля класса отсутствуют.

Атрибуты экземпляра:
    __rows: list[list[Number]] - строки матрицы
    n: int - количество строк
    m: int - количество столбцов

Свойства:
    transpose -> Self
        геттер - возвращает транспонированную матрицу

Методы:
    __init__()
        конструктор класса
    
    {static} is_valid() -> bool
        проверяет, является ли переданный аргумент подходящим объектом для конструирования матрицы
        
        Объект является подходящим, если он представляет из себя итерируемый объект, элементами которого являются итерируемые объекты одинаковой длины, элементами которых являются числа любого типа.
            
            Для аннотации итерируемого объекта используется (аналогично list) дженерик Iterable из модуля collections.abc стандартной библиотеки
            
            Для аннотации любого числового типа используется дженерик Number из модуля numbers стандартной библиотеки
    
    __getitem__() -> list[Number]
        обеспечивает доступ на чтение к строкам матрицы по индексу
    
    __element_wise_operation() -> Self
        выполняет переданную операцию со своим и переданным объектами
            
            В модуле operator есть функции, работающие аналогично операторам: например, add(), sub() и mul()
            
            Для аннотации экземпляра объявляемого класса используется дженерик Self из модуля typing стандартной библиотеки
    
    __add__() -> Self
        перегрузка бинарного оператора +
        
        В качестве меры по минимизации повторяемости кода предлагается использовать метод __element_wise_operation()
    
    __radd__() -> Self
        правостронняя перегрузка бинарного оператора +
        
        В качестве меры по минимизации повторяемости кода предлагается использовать метод __element_wise_operation()
    
    __neg__() -> Self
        перегрузка унарного оператора -
        
        В качестве меры по минимизации повторяемости кода предлагается использовать метод __element_wise_operation()

    __sub__() -> Self
        перегрузка бинарного оператора -
        
        В качестве меры по минимизации повторяемости кода предлагается использовать метод __element_wise_operation()
    
    __rsub__() -> Self
        правостронняя перегрузка бинарного оператора -
        
        В качестве меры по минимизации повторяемости кода предлагается использовать метод __element_wise_operation()
    
    __mul__() -> Self
        перегрузка бинарного оператора *
    
    __rmul__() -> Self
        правостронняя перегрузка бинарного оператора *
        
        В качестве меры по минимизации повторяемости кода предлагается использовать метод __element_wise_operation()
    
    __repr__()
        строковое представление матрицы
        
        Столбцы матрицы должны быть колонками с выравниванием вправо, расстояние между колонками — один пробел.

Параметры конструктора:
    raw_matrix: Iterable[Iterable[Number]]

Параметры is_valid():
    raw_matrix: Iterable[Iterable[Number]]

Параметры __element_wise_operation():
    other: Self | Number
    operation: Callable


Для сложных аннотаций предпочтительно создавать отдельные переменные-дженерики, например:
    RawRow = Iterable[Number]
    RawMatrix = Iterable[RawRow]

Написанный класс необходимо протестировать.
Пример теста:
    >>> 
    >>> Matrix([[1, 2], [1, 2, 3, 4]])
    ...
    ValueError: невозможно сконструировать матрицу
    >>> 
    >>> m1 = Matrix([[1, 1, 1], [1, 1, 1]])
    >>> m2 = Matrix([[3, 3, 3], [3, 3, 3]])
    >>> 
    >>> m1
    1 1 1
    1 1 1
    >>> 
    >>> m2
    3 3 3
    3 3 3
    >>>
    >>> for i in range(m1.n):
    ...     for j in range(m1.m):
    ...         print(m1[i][j], end=' ')
    ...
    1 1 1 1 1 1 >>>
    >>>
    >>> m2.transpose
    3 3
    3 3
    3 3
    >>> 
    >>> m1 + m2
    4 4 4
    4 4 4
    >>> 
    >>> m1 - m2
    -2 -2 -2
    -2 -2 -2
    >>> 
    >>> m1 * m2
    ...
    NotImplementedError: умножение матриц будет реализовано в будущем
    >>> 
    >>> 5 + m1
    6 6 6
    6 6 6
    >>> 
    >>> 10 - m2
    7 7 7
    7 7 7
    >>> 
    >>> m1[0][2] = 7
    >>> m1[1][2] = 7
    >>>
    >>> m1
    1 1 7
    1 1 7
    >>>
    >>> m1.transpose
    1 1
    1 1
    7 7
    >>>
    >>> m3 = Matrix([[1, 2], [3, 4]])
    >>> 
    >>> m3 + m1
    ...
    ValueError: сложение и вычитание возможно только для матриц одной размерности
    >>> 
    >>> m3 * 3.9
     3.9  7.8
    11.7 15.6
    >>> 
    >>> -m3
    -1 -2
    -3 -4
    >>> 
    >>> m3 + [2, 1]
    ...
    TypeError: алгебраические операции возможны только с матрицами и числами



  ==========  2  ==========  

Написать класс с именем Matrix, который описывает матрицу чисел.
Элементами матрицы могут быть объекты любого числового типа.

Данный класс будет моделировать неизменяемую матрицу. Для этого доступ к элементам матрицы должен быть запрещён (насколько это возможно в Python).

Класс должен поддерживать операции:
  - транспонирования
  - поэлементного сложения с другой матрицей и числом
  - поэлементного вычитания с другой матрицей и числом
  - поэлементного умножения на число
  - унарного отрицания
  - строкового представления матрицы с выравниванием столбцов

Необходимо минимизировать повторения кода для перегружающих операторы методов.


Поля класса отсутствуют.

Атрибуты экземпляра:
    __flat: tuple[Number, ...] - элементы матрицы в порядке: числа первой строки, числа второй строки, ...
    n: int - количество строк
    m: int - количество столбцов
    __transpose: Iterable[Number] - элементы матрицы в порядке: числа первого столбца, числа второго столбца, ... 

Свойства:
    transpose -> Self
        геттер - возвращает транспонированную матрицу
        
        Рекомендуется кэшировать данное свойство. Для этого вместо декоратора property рекомендуется воспользоваться декоратором cached_property из модуля functools стандартной библиотеки.

Методы:
    __init__()
        конструктор класса
    
    {static} is_valid() -> bool
        проверяет, является ли переданный аргумент подходящим объектом для конструирования матрицы
        
        Объект является подходящим, если он представляет из себя итерируемый объект, элементами которого являются числа любого типа, и длина длина этого объекта равна произведению переданных размеров матрицы.
    
    __element_wise_operation() -> Self
        выполняет переданную операцию со своим и переданным объектами
            
            В отличие от предыдущей задачи, в данном методе предлагается реализовать только операции сложения и вычитания.
    
    __add__() -> Self
        перегрузка бинарного оператора +
        
        В качестве меры по минимизации повторяемости кода предлагается использовать метод __element_wise_operation()
    
    __radd__() -> Self
        правостронняя перегрузка бинарного оператора +
        
        В отличие от предыдущей задачи, в качестве меры по минимизации повторяемости кода предлагается использовать метод __add__()
    
    __neg__() -> Self
        перегрузка унарного оператора -
        
        В отличие от предыдущей задачи, в качестве меры по минимизации повторяемости кода предлагается использовать метод __mul__()

    __sub__() -> Self
        перегрузка бинарного оператора -
        
        В качестве меры по минимизации повторяемости кода предлагается использовать метод __element_wise_operation()
    
    __rsub__() -> Self
        правостронняя перегрузка бинарного оператора -
        
        В отличие от предыдущей задачи, в качестве меры по минимизации повторяемости кода предлагается использовать метод __sub__()
    
    __mul__() -> Self
        перегрузка бинарного оператора *
    
    __rmul__() -> Self
        правостронняя перегрузка бинарного оператора *
        
        В отличие от предыдущей задачи, в качестве меры по минимизации повторяемости кода предлагается использовать метод __mul__()
    
    __repr__()
        строковое представление матрицы
        
        Столбцы матрицы должны быть колонками с выравниванием вправо, расстояние между колонками — один пробел.
        
        Рекомендуется кэшировать данный метод. Для этого можно воспользоваться декоратором cache из модуля functools стандартной библиотеки.

Параметры конструктора:
    *raw_matrix: Number - произвольный кортеж
    n: int - строго ключевой
    m: int - строго ключевой

Параметры is_valid():
    raw_matrix: Iterable[Number]
    n: int
    m: int

Параметры __element_wise_operation():
    other: Self | Number
    operation: Callable


Написанный класс необходимо протестировать.
Пример теста:
    >>> 
    >>> Matrix(1, 2, 3, 4, 5, n=2, m=3)
    ...
    ValueError: невозможно сконструировать матрицу
    >>> 
    >>> from itertools import repeat
    >>> 
    >>> m1 = Matrix(*repeat(1, 15), n=3, m=5)
    >>> m2 = Matrix(*range(1, 16), n=3, m=5)
    >>> 
    >>> m1
    1 1 1 1 1
    1 1 1 1 1
    1 1 1 1 1
    >>>
    >>> m2
     1  2  3  4  5
     6  7  8  9 10
    11 12 13 14 15
    >>>
    >>> m1[0][0]
    ...
    TypeError: 'Matrix' object is not subscriptable
    >>>
    >>> m2.transpose
     1  6 11
     2  7 12
     3  8 13
     4  9 14
     5 10 15
    >>>
    >>> m1 + m1
    2 2 2 2 2
    2 2 2 2 2
    2 2 2 2 2
    >>>
    >>> m2 - m1
     0  1  2  3  4
     5  6  7  8  9
    10 11 12 13 14
    >>>
    >>> m1 * m2
    ...
    NotImplementedError: умножение матриц будет реализовано в будущем
    >>>
    >>> 3 + m1
    4 4 4 4 4
    4 4 4 4 4
    4 4 4 4 4
    >>> 
    >>> m2.transpose - 10
    -9 -4  1
    -8 -3  2
    -7 -2  3
    -6 -1  4
    -5  0  5
    >>>
    >>> -1.5 - m1
    -2.5 -2.5 -2.5 -2.5 -2.5
    -2.5 -2.5 -2.5 -2.5 -2.5
    -2.5 -2.5 -2.5 -2.5 -2.5
    >>>
    >>> m3 + m1
    ...
    ValueError: сложение и вычитание возможно только для матриц одной размерности
    >>> 
    >>> m3 = Matrix(*range(1, 5), n=2, m=2)
    >>> 
    >>> m3
    1 2
    3 4
    >>> 
    >>> m3 * 4.5
     4.5  9.0
    13.5 18.0
    >>>
    >>> -m3
    -1 -2
    -3 -4
    >>>
    >>> m3 - [4, 3, 2, 1]
    ...
    TypeError: алгебраические операции возможны только с матрицами и числами



  =========================

Каждый класс должен быть документирован. 
Каждый метод кроме специальных должен быть документирован.

Каждое поле класса должно быть аннотировано. 
Атрибуты экземпляра аннотируются в том случае, если типы их значений не совпадают с соответствующими переданными в конструктор аргументами, или если атрибуты создаются безотносительно переданных в конструктор аргументов.
Каждый параметр (кроме self и cls) всех методов должен быть аннотирован. 
Каждое возвращаемое значение методов кроме специальных должно быть аннотировано.

Во всех случаях аннотация опускается, если с аннотируемым идентификатором может быть связан объект произвольного типа.

Помимо перечисленных в каждой задаче обязательных атрибутов классов и экземпляров возможно добавление собственных вспомогательных атрибутов и методов.

Работа классов тестируется в режиме инспекции файла с кодом.
Ввод и вывод в стандартные потоки результатов тестов копируются.
Копия в виде комментария помещается в конец файла с кодом задачи.

Невыполнение дополнительных задач не повлечёт снижения баллов за задание. Тем не менее они настоятельно рекомендуются к решению.

В сервис Журнал отправляется сообщение о выполнении всех частей задания со ссылкой на репозиторий.

Преподаватель пишет комментарии и правки в коде задач и обновляет файлы в удалённом репозитории.
Регулярно получайте обновления в свой локальный репозиторий из удалённого репозитория.